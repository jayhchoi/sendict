module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.31.1). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateLike {
  count: Int!
}

type AggregateSentence {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

type Like {
  id: ID!
  user: User!
  sentence: Sentence!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type LikeConnection {
  pageInfo: PageInfo!
  edges: [LikeEdge]!
  aggregate: AggregateLike!
}

input LikeCreateInput {
  user: UserCreateOneWithoutLikesInput!
  sentence: SentenceCreateOneWithoutLikesInput!
}

input LikeCreateManyWithoutSentenceInput {
  create: [LikeCreateWithoutSentenceInput!]
  connect: [LikeWhereUniqueInput!]
}

input LikeCreateManyWithoutUserInput {
  create: [LikeCreateWithoutUserInput!]
  connect: [LikeWhereUniqueInput!]
}

input LikeCreateWithoutSentenceInput {
  user: UserCreateOneWithoutLikesInput!
}

input LikeCreateWithoutUserInput {
  sentence: SentenceCreateOneWithoutLikesInput!
}

type LikeEdge {
  node: Like!
  cursor: String!
}

enum LikeOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type LikePreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input LikeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [LikeScalarWhereInput!]
  OR: [LikeScalarWhereInput!]
  NOT: [LikeScalarWhereInput!]
}

type LikeSubscriptionPayload {
  mutation: MutationType!
  node: Like
  updatedFields: [String!]
  previousValues: LikePreviousValues
}

input LikeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LikeWhereInput
  AND: [LikeSubscriptionWhereInput!]
  OR: [LikeSubscriptionWhereInput!]
  NOT: [LikeSubscriptionWhereInput!]
}

input LikeUpdateInput {
  user: UserUpdateOneRequiredWithoutLikesInput
  sentence: SentenceUpdateOneRequiredWithoutLikesInput
}

input LikeUpdateManyWithoutSentenceInput {
  create: [LikeCreateWithoutSentenceInput!]
  delete: [LikeWhereUniqueInput!]
  connect: [LikeWhereUniqueInput!]
  set: [LikeWhereUniqueInput!]
  disconnect: [LikeWhereUniqueInput!]
  update: [LikeUpdateWithWhereUniqueWithoutSentenceInput!]
  upsert: [LikeUpsertWithWhereUniqueWithoutSentenceInput!]
  deleteMany: [LikeScalarWhereInput!]
}

input LikeUpdateManyWithoutUserInput {
  create: [LikeCreateWithoutUserInput!]
  delete: [LikeWhereUniqueInput!]
  connect: [LikeWhereUniqueInput!]
  set: [LikeWhereUniqueInput!]
  disconnect: [LikeWhereUniqueInput!]
  update: [LikeUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [LikeUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [LikeScalarWhereInput!]
}

input LikeUpdateWithoutSentenceDataInput {
  user: UserUpdateOneRequiredWithoutLikesInput
}

input LikeUpdateWithoutUserDataInput {
  sentence: SentenceUpdateOneRequiredWithoutLikesInput
}

input LikeUpdateWithWhereUniqueWithoutSentenceInput {
  where: LikeWhereUniqueInput!
  data: LikeUpdateWithoutSentenceDataInput!
}

input LikeUpdateWithWhereUniqueWithoutUserInput {
  where: LikeWhereUniqueInput!
  data: LikeUpdateWithoutUserDataInput!
}

input LikeUpsertWithWhereUniqueWithoutSentenceInput {
  where: LikeWhereUniqueInput!
  update: LikeUpdateWithoutSentenceDataInput!
  create: LikeCreateWithoutSentenceInput!
}

input LikeUpsertWithWhereUniqueWithoutUserInput {
  where: LikeWhereUniqueInput!
  update: LikeUpdateWithoutUserDataInput!
  create: LikeCreateWithoutUserInput!
}

input LikeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  sentence: SentenceWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [LikeWhereInput!]
  OR: [LikeWhereInput!]
  NOT: [LikeWhereInput!]
}

input LikeWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createLike(data: LikeCreateInput!): Like!
  updateLike(data: LikeUpdateInput!, where: LikeWhereUniqueInput!): Like
  upsertLike(where: LikeWhereUniqueInput!, create: LikeCreateInput!, update: LikeUpdateInput!): Like!
  deleteLike(where: LikeWhereUniqueInput!): Like
  deleteManyLikes(where: LikeWhereInput): BatchPayload!
  createSentence(data: SentenceCreateInput!): Sentence!
  updateSentence(data: SentenceUpdateInput!, where: SentenceWhereUniqueInput!): Sentence
  updateManySentences(data: SentenceUpdateManyMutationInput!, where: SentenceWhereInput): BatchPayload!
  upsertSentence(where: SentenceWhereUniqueInput!, create: SentenceCreateInput!, update: SentenceUpdateInput!): Sentence!
  deleteSentence(where: SentenceWhereUniqueInput!): Sentence
  deleteManySentences(where: SentenceWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  like(where: LikeWhereUniqueInput!): Like
  likes(where: LikeWhereInput, orderBy: LikeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Like]!
  likesConnection(where: LikeWhereInput, orderBy: LikeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LikeConnection!
  sentence(where: SentenceWhereUniqueInput!): Sentence
  sentences(where: SentenceWhereInput, orderBy: SentenceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Sentence]!
  sentencesConnection(where: SentenceWhereInput, orderBy: SentenceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SentenceConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Sentence {
  id: ID!
  english: String!
  korean: String!
  tags: [String!]!
  user: User!
  likes(where: LikeWhereInput, orderBy: LikeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Like!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SentenceConnection {
  pageInfo: PageInfo!
  edges: [SentenceEdge]!
  aggregate: AggregateSentence!
}

input SentenceCreateInput {
  english: String!
  korean: String!
  tags: SentenceCreatetagsInput
  user: UserCreateOneWithoutSentencesInput!
  likes: LikeCreateManyWithoutSentenceInput
}

input SentenceCreateManyWithoutUserInput {
  create: [SentenceCreateWithoutUserInput!]
  connect: [SentenceWhereUniqueInput!]
}

input SentenceCreateOneWithoutLikesInput {
  create: SentenceCreateWithoutLikesInput
  connect: SentenceWhereUniqueInput
}

input SentenceCreatetagsInput {
  set: [String!]
}

input SentenceCreateWithoutLikesInput {
  english: String!
  korean: String!
  tags: SentenceCreatetagsInput
  user: UserCreateOneWithoutSentencesInput!
}

input SentenceCreateWithoutUserInput {
  english: String!
  korean: String!
  tags: SentenceCreatetagsInput
  likes: LikeCreateManyWithoutSentenceInput
}

type SentenceEdge {
  node: Sentence!
  cursor: String!
}

enum SentenceOrderByInput {
  id_ASC
  id_DESC
  english_ASC
  english_DESC
  korean_ASC
  korean_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SentencePreviousValues {
  id: ID!
  english: String!
  korean: String!
  tags: [String!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input SentenceScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  english: String
  english_not: String
  english_in: [String!]
  english_not_in: [String!]
  english_lt: String
  english_lte: String
  english_gt: String
  english_gte: String
  english_contains: String
  english_not_contains: String
  english_starts_with: String
  english_not_starts_with: String
  english_ends_with: String
  english_not_ends_with: String
  korean: String
  korean_not: String
  korean_in: [String!]
  korean_not_in: [String!]
  korean_lt: String
  korean_lte: String
  korean_gt: String
  korean_gte: String
  korean_contains: String
  korean_not_contains: String
  korean_starts_with: String
  korean_not_starts_with: String
  korean_ends_with: String
  korean_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [SentenceScalarWhereInput!]
  OR: [SentenceScalarWhereInput!]
  NOT: [SentenceScalarWhereInput!]
}

type SentenceSubscriptionPayload {
  mutation: MutationType!
  node: Sentence
  updatedFields: [String!]
  previousValues: SentencePreviousValues
}

input SentenceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SentenceWhereInput
  AND: [SentenceSubscriptionWhereInput!]
  OR: [SentenceSubscriptionWhereInput!]
  NOT: [SentenceSubscriptionWhereInput!]
}

input SentenceUpdateInput {
  english: String
  korean: String
  tags: SentenceUpdatetagsInput
  user: UserUpdateOneRequiredWithoutSentencesInput
  likes: LikeUpdateManyWithoutSentenceInput
}

input SentenceUpdateManyDataInput {
  english: String
  korean: String
  tags: SentenceUpdatetagsInput
}

input SentenceUpdateManyMutationInput {
  english: String
  korean: String
  tags: SentenceUpdatetagsInput
}

input SentenceUpdateManyWithoutUserInput {
  create: [SentenceCreateWithoutUserInput!]
  delete: [SentenceWhereUniqueInput!]
  connect: [SentenceWhereUniqueInput!]
  set: [SentenceWhereUniqueInput!]
  disconnect: [SentenceWhereUniqueInput!]
  update: [SentenceUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [SentenceUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [SentenceScalarWhereInput!]
  updateMany: [SentenceUpdateManyWithWhereNestedInput!]
}

input SentenceUpdateManyWithWhereNestedInput {
  where: SentenceScalarWhereInput!
  data: SentenceUpdateManyDataInput!
}

input SentenceUpdateOneRequiredWithoutLikesInput {
  create: SentenceCreateWithoutLikesInput
  update: SentenceUpdateWithoutLikesDataInput
  upsert: SentenceUpsertWithoutLikesInput
  connect: SentenceWhereUniqueInput
}

input SentenceUpdatetagsInput {
  set: [String!]
}

input SentenceUpdateWithoutLikesDataInput {
  english: String
  korean: String
  tags: SentenceUpdatetagsInput
  user: UserUpdateOneRequiredWithoutSentencesInput
}

input SentenceUpdateWithoutUserDataInput {
  english: String
  korean: String
  tags: SentenceUpdatetagsInput
  likes: LikeUpdateManyWithoutSentenceInput
}

input SentenceUpdateWithWhereUniqueWithoutUserInput {
  where: SentenceWhereUniqueInput!
  data: SentenceUpdateWithoutUserDataInput!
}

input SentenceUpsertWithoutLikesInput {
  update: SentenceUpdateWithoutLikesDataInput!
  create: SentenceCreateWithoutLikesInput!
}

input SentenceUpsertWithWhereUniqueWithoutUserInput {
  where: SentenceWhereUniqueInput!
  update: SentenceUpdateWithoutUserDataInput!
  create: SentenceCreateWithoutUserInput!
}

input SentenceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  english: String
  english_not: String
  english_in: [String!]
  english_not_in: [String!]
  english_lt: String
  english_lte: String
  english_gt: String
  english_gte: String
  english_contains: String
  english_not_contains: String
  english_starts_with: String
  english_not_starts_with: String
  english_ends_with: String
  english_not_ends_with: String
  korean: String
  korean_not: String
  korean_in: [String!]
  korean_not_in: [String!]
  korean_lt: String
  korean_lte: String
  korean_gt: String
  korean_gte: String
  korean_contains: String
  korean_not_contains: String
  korean_starts_with: String
  korean_not_starts_with: String
  korean_ends_with: String
  korean_not_ends_with: String
  user: UserWhereInput
  likes_every: LikeWhereInput
  likes_some: LikeWhereInput
  likes_none: LikeWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [SentenceWhereInput!]
  OR: [SentenceWhereInput!]
  NOT: [SentenceWhereInput!]
}

input SentenceWhereUniqueInput {
  id: ID
}

type Subscription {
  like(where: LikeSubscriptionWhereInput): LikeSubscriptionPayload
  sentence(where: SentenceSubscriptionWhereInput): SentenceSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  email: String!
  name: String!
  sentences(where: SentenceWhereInput, orderBy: SentenceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Sentence!]
  likes(where: LikeWhereInput, orderBy: LikeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Like!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  email: String!
  name: String!
  sentences: SentenceCreateManyWithoutUserInput
  likes: LikeCreateManyWithoutUserInput
}

input UserCreateOneWithoutLikesInput {
  create: UserCreateWithoutLikesInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutSentencesInput {
  create: UserCreateWithoutSentencesInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutLikesInput {
  email: String!
  name: String!
  sentences: SentenceCreateManyWithoutUserInput
}

input UserCreateWithoutSentencesInput {
  email: String!
  name: String!
  likes: LikeCreateManyWithoutUserInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  email: String!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  email: String
  name: String
  sentences: SentenceUpdateManyWithoutUserInput
  likes: LikeUpdateManyWithoutUserInput
}

input UserUpdateManyMutationInput {
  email: String
  name: String
}

input UserUpdateOneRequiredWithoutLikesInput {
  create: UserCreateWithoutLikesInput
  update: UserUpdateWithoutLikesDataInput
  upsert: UserUpsertWithoutLikesInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutSentencesInput {
  create: UserCreateWithoutSentencesInput
  update: UserUpdateWithoutSentencesDataInput
  upsert: UserUpsertWithoutSentencesInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutLikesDataInput {
  email: String
  name: String
  sentences: SentenceUpdateManyWithoutUserInput
}

input UserUpdateWithoutSentencesDataInput {
  email: String
  name: String
  likes: LikeUpdateManyWithoutUserInput
}

input UserUpsertWithoutLikesInput {
  update: UserUpdateWithoutLikesDataInput!
  create: UserCreateWithoutLikesInput!
}

input UserUpsertWithoutSentencesInput {
  update: UserUpdateWithoutSentencesDataInput!
  create: UserCreateWithoutSentencesInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  sentences_every: SentenceWhereInput
  sentences_some: SentenceWhereInput
  sentences_none: SentenceWhereInput
  likes_every: LikeWhereInput
  likes_some: LikeWhereInput
  likes_none: LikeWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
`
      }
    