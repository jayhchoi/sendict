module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.31.1). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateDictionary {
  count: Int!
}

type AggregateSentence {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

type Dictionary {
  id: ID!
  user: User!
  sentences(where: SentenceWhereInput, orderBy: SentenceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Sentence!]
}

type DictionaryConnection {
  pageInfo: PageInfo!
  edges: [DictionaryEdge]!
  aggregate: AggregateDictionary!
}

input DictionaryCreateInput {
  user: UserCreateOneWithoutDictionaryInput!
  sentences: SentenceCreateManyWithoutDictionariesInput
}

input DictionaryCreateManyWithoutSentencesInput {
  create: [DictionaryCreateWithoutSentencesInput!]
  connect: [DictionaryWhereUniqueInput!]
}

input DictionaryCreateOneWithoutUserInput {
  create: DictionaryCreateWithoutUserInput
  connect: DictionaryWhereUniqueInput
}

input DictionaryCreateWithoutSentencesInput {
  user: UserCreateOneWithoutDictionaryInput!
}

input DictionaryCreateWithoutUserInput {
  sentences: SentenceCreateManyWithoutDictionariesInput
}

type DictionaryEdge {
  node: Dictionary!
  cursor: String!
}

enum DictionaryOrderByInput {
  id_ASC
  id_DESC
}

type DictionaryPreviousValues {
  id: ID!
}

input DictionaryScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [DictionaryScalarWhereInput!]
  OR: [DictionaryScalarWhereInput!]
  NOT: [DictionaryScalarWhereInput!]
}

type DictionarySubscriptionPayload {
  mutation: MutationType!
  node: Dictionary
  updatedFields: [String!]
  previousValues: DictionaryPreviousValues
}

input DictionarySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DictionaryWhereInput
  AND: [DictionarySubscriptionWhereInput!]
  OR: [DictionarySubscriptionWhereInput!]
  NOT: [DictionarySubscriptionWhereInput!]
}

input DictionaryUpdateInput {
  user: UserUpdateOneRequiredWithoutDictionaryInput
  sentences: SentenceUpdateManyWithoutDictionariesInput
}

input DictionaryUpdateManyWithoutSentencesInput {
  create: [DictionaryCreateWithoutSentencesInput!]
  delete: [DictionaryWhereUniqueInput!]
  connect: [DictionaryWhereUniqueInput!]
  set: [DictionaryWhereUniqueInput!]
  disconnect: [DictionaryWhereUniqueInput!]
  update: [DictionaryUpdateWithWhereUniqueWithoutSentencesInput!]
  upsert: [DictionaryUpsertWithWhereUniqueWithoutSentencesInput!]
  deleteMany: [DictionaryScalarWhereInput!]
}

input DictionaryUpdateOneRequiredWithoutUserInput {
  create: DictionaryCreateWithoutUserInput
  update: DictionaryUpdateWithoutUserDataInput
  upsert: DictionaryUpsertWithoutUserInput
  connect: DictionaryWhereUniqueInput
}

input DictionaryUpdateWithoutSentencesDataInput {
  user: UserUpdateOneRequiredWithoutDictionaryInput
}

input DictionaryUpdateWithoutUserDataInput {
  sentences: SentenceUpdateManyWithoutDictionariesInput
}

input DictionaryUpdateWithWhereUniqueWithoutSentencesInput {
  where: DictionaryWhereUniqueInput!
  data: DictionaryUpdateWithoutSentencesDataInput!
}

input DictionaryUpsertWithoutUserInput {
  update: DictionaryUpdateWithoutUserDataInput!
  create: DictionaryCreateWithoutUserInput!
}

input DictionaryUpsertWithWhereUniqueWithoutSentencesInput {
  where: DictionaryWhereUniqueInput!
  update: DictionaryUpdateWithoutSentencesDataInput!
  create: DictionaryCreateWithoutSentencesInput!
}

input DictionaryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  sentences_every: SentenceWhereInput
  sentences_some: SentenceWhereInput
  sentences_none: SentenceWhereInput
  AND: [DictionaryWhereInput!]
  OR: [DictionaryWhereInput!]
  NOT: [DictionaryWhereInput!]
}

input DictionaryWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createDictionary(data: DictionaryCreateInput!): Dictionary!
  updateDictionary(data: DictionaryUpdateInput!, where: DictionaryWhereUniqueInput!): Dictionary
  upsertDictionary(where: DictionaryWhereUniqueInput!, create: DictionaryCreateInput!, update: DictionaryUpdateInput!): Dictionary!
  deleteDictionary(where: DictionaryWhereUniqueInput!): Dictionary
  deleteManyDictionaries(where: DictionaryWhereInput): BatchPayload!
  createSentence(data: SentenceCreateInput!): Sentence!
  updateSentence(data: SentenceUpdateInput!, where: SentenceWhereUniqueInput!): Sentence
  updateManySentences(data: SentenceUpdateManyMutationInput!, where: SentenceWhereInput): BatchPayload!
  upsertSentence(where: SentenceWhereUniqueInput!, create: SentenceCreateInput!, update: SentenceUpdateInput!): Sentence!
  deleteSentence(where: SentenceWhereUniqueInput!): Sentence
  deleteManySentences(where: SentenceWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  dictionary(where: DictionaryWhereUniqueInput!): Dictionary
  dictionaries(where: DictionaryWhereInput, orderBy: DictionaryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Dictionary]!
  dictionariesConnection(where: DictionaryWhereInput, orderBy: DictionaryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DictionaryConnection!
  sentence(where: SentenceWhereUniqueInput!): Sentence
  sentences(where: SentenceWhereInput, orderBy: SentenceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Sentence]!
  sentencesConnection(where: SentenceWhereInput, orderBy: SentenceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SentenceConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Sentence {
  id: ID!
  english: String!
  korean: String!
  source: String
  label: String
  author: User!
  dictionaries(where: DictionaryWhereInput, orderBy: DictionaryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Dictionary!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SentenceConnection {
  pageInfo: PageInfo!
  edges: [SentenceEdge]!
  aggregate: AggregateSentence!
}

input SentenceCreateInput {
  english: String!
  korean: String!
  source: String
  label: String
  author: UserCreateOneWithoutMySentencesInput!
  dictionaries: DictionaryCreateManyWithoutSentencesInput
}

input SentenceCreateManyWithoutAuthorInput {
  create: [SentenceCreateWithoutAuthorInput!]
  connect: [SentenceWhereUniqueInput!]
}

input SentenceCreateManyWithoutDictionariesInput {
  create: [SentenceCreateWithoutDictionariesInput!]
  connect: [SentenceWhereUniqueInput!]
}

input SentenceCreateWithoutAuthorInput {
  english: String!
  korean: String!
  source: String
  label: String
  dictionaries: DictionaryCreateManyWithoutSentencesInput
}

input SentenceCreateWithoutDictionariesInput {
  english: String!
  korean: String!
  source: String
  label: String
  author: UserCreateOneWithoutMySentencesInput!
}

type SentenceEdge {
  node: Sentence!
  cursor: String!
}

enum SentenceOrderByInput {
  id_ASC
  id_DESC
  english_ASC
  english_DESC
  korean_ASC
  korean_DESC
  source_ASC
  source_DESC
  label_ASC
  label_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SentencePreviousValues {
  id: ID!
  english: String!
  korean: String!
  source: String
  label: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

input SentenceScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  english: String
  english_not: String
  english_in: [String!]
  english_not_in: [String!]
  english_lt: String
  english_lte: String
  english_gt: String
  english_gte: String
  english_contains: String
  english_not_contains: String
  english_starts_with: String
  english_not_starts_with: String
  english_ends_with: String
  english_not_ends_with: String
  korean: String
  korean_not: String
  korean_in: [String!]
  korean_not_in: [String!]
  korean_lt: String
  korean_lte: String
  korean_gt: String
  korean_gte: String
  korean_contains: String
  korean_not_contains: String
  korean_starts_with: String
  korean_not_starts_with: String
  korean_ends_with: String
  korean_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  label: String
  label_not: String
  label_in: [String!]
  label_not_in: [String!]
  label_lt: String
  label_lte: String
  label_gt: String
  label_gte: String
  label_contains: String
  label_not_contains: String
  label_starts_with: String
  label_not_starts_with: String
  label_ends_with: String
  label_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [SentenceScalarWhereInput!]
  OR: [SentenceScalarWhereInput!]
  NOT: [SentenceScalarWhereInput!]
}

type SentenceSubscriptionPayload {
  mutation: MutationType!
  node: Sentence
  updatedFields: [String!]
  previousValues: SentencePreviousValues
}

input SentenceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SentenceWhereInput
  AND: [SentenceSubscriptionWhereInput!]
  OR: [SentenceSubscriptionWhereInput!]
  NOT: [SentenceSubscriptionWhereInput!]
}

input SentenceUpdateInput {
  english: String
  korean: String
  source: String
  label: String
  author: UserUpdateOneRequiredWithoutMySentencesInput
  dictionaries: DictionaryUpdateManyWithoutSentencesInput
}

input SentenceUpdateManyDataInput {
  english: String
  korean: String
  source: String
  label: String
}

input SentenceUpdateManyMutationInput {
  english: String
  korean: String
  source: String
  label: String
}

input SentenceUpdateManyWithoutAuthorInput {
  create: [SentenceCreateWithoutAuthorInput!]
  delete: [SentenceWhereUniqueInput!]
  connect: [SentenceWhereUniqueInput!]
  set: [SentenceWhereUniqueInput!]
  disconnect: [SentenceWhereUniqueInput!]
  update: [SentenceUpdateWithWhereUniqueWithoutAuthorInput!]
  upsert: [SentenceUpsertWithWhereUniqueWithoutAuthorInput!]
  deleteMany: [SentenceScalarWhereInput!]
  updateMany: [SentenceUpdateManyWithWhereNestedInput!]
}

input SentenceUpdateManyWithoutDictionariesInput {
  create: [SentenceCreateWithoutDictionariesInput!]
  delete: [SentenceWhereUniqueInput!]
  connect: [SentenceWhereUniqueInput!]
  set: [SentenceWhereUniqueInput!]
  disconnect: [SentenceWhereUniqueInput!]
  update: [SentenceUpdateWithWhereUniqueWithoutDictionariesInput!]
  upsert: [SentenceUpsertWithWhereUniqueWithoutDictionariesInput!]
  deleteMany: [SentenceScalarWhereInput!]
  updateMany: [SentenceUpdateManyWithWhereNestedInput!]
}

input SentenceUpdateManyWithWhereNestedInput {
  where: SentenceScalarWhereInput!
  data: SentenceUpdateManyDataInput!
}

input SentenceUpdateWithoutAuthorDataInput {
  english: String
  korean: String
  source: String
  label: String
  dictionaries: DictionaryUpdateManyWithoutSentencesInput
}

input SentenceUpdateWithoutDictionariesDataInput {
  english: String
  korean: String
  source: String
  label: String
  author: UserUpdateOneRequiredWithoutMySentencesInput
}

input SentenceUpdateWithWhereUniqueWithoutAuthorInput {
  where: SentenceWhereUniqueInput!
  data: SentenceUpdateWithoutAuthorDataInput!
}

input SentenceUpdateWithWhereUniqueWithoutDictionariesInput {
  where: SentenceWhereUniqueInput!
  data: SentenceUpdateWithoutDictionariesDataInput!
}

input SentenceUpsertWithWhereUniqueWithoutAuthorInput {
  where: SentenceWhereUniqueInput!
  update: SentenceUpdateWithoutAuthorDataInput!
  create: SentenceCreateWithoutAuthorInput!
}

input SentenceUpsertWithWhereUniqueWithoutDictionariesInput {
  where: SentenceWhereUniqueInput!
  update: SentenceUpdateWithoutDictionariesDataInput!
  create: SentenceCreateWithoutDictionariesInput!
}

input SentenceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  english: String
  english_not: String
  english_in: [String!]
  english_not_in: [String!]
  english_lt: String
  english_lte: String
  english_gt: String
  english_gte: String
  english_contains: String
  english_not_contains: String
  english_starts_with: String
  english_not_starts_with: String
  english_ends_with: String
  english_not_ends_with: String
  korean: String
  korean_not: String
  korean_in: [String!]
  korean_not_in: [String!]
  korean_lt: String
  korean_lte: String
  korean_gt: String
  korean_gte: String
  korean_contains: String
  korean_not_contains: String
  korean_starts_with: String
  korean_not_starts_with: String
  korean_ends_with: String
  korean_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  label: String
  label_not: String
  label_in: [String!]
  label_not_in: [String!]
  label_lt: String
  label_lte: String
  label_gt: String
  label_gte: String
  label_contains: String
  label_not_contains: String
  label_starts_with: String
  label_not_starts_with: String
  label_ends_with: String
  label_not_ends_with: String
  author: UserWhereInput
  dictionaries_every: DictionaryWhereInput
  dictionaries_some: DictionaryWhereInput
  dictionaries_none: DictionaryWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [SentenceWhereInput!]
  OR: [SentenceWhereInput!]
  NOT: [SentenceWhereInput!]
}

input SentenceWhereUniqueInput {
  id: ID
}

type Subscription {
  dictionary(where: DictionarySubscriptionWhereInput): DictionarySubscriptionPayload
  sentence(where: SentenceSubscriptionWhereInput): SentenceSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  email: String!
  username: String!
  avatar: String!
  password: String!
  name: String!
  mySentences(where: SentenceWhereInput, orderBy: SentenceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Sentence!]
  dictionary: Dictionary!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  email: String!
  username: String!
  avatar: String!
  password: String!
  name: String!
  mySentences: SentenceCreateManyWithoutAuthorInput
  dictionary: DictionaryCreateOneWithoutUserInput!
}

input UserCreateOneWithoutDictionaryInput {
  create: UserCreateWithoutDictionaryInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutMySentencesInput {
  create: UserCreateWithoutMySentencesInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutDictionaryInput {
  email: String!
  username: String!
  avatar: String!
  password: String!
  name: String!
  mySentences: SentenceCreateManyWithoutAuthorInput
}

input UserCreateWithoutMySentencesInput {
  email: String!
  username: String!
  avatar: String!
  password: String!
  name: String!
  dictionary: DictionaryCreateOneWithoutUserInput!
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  username_ASC
  username_DESC
  avatar_ASC
  avatar_DESC
  password_ASC
  password_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  email: String!
  username: String!
  avatar: String!
  password: String!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  email: String
  username: String
  avatar: String
  password: String
  name: String
  mySentences: SentenceUpdateManyWithoutAuthorInput
  dictionary: DictionaryUpdateOneRequiredWithoutUserInput
}

input UserUpdateManyMutationInput {
  email: String
  username: String
  avatar: String
  password: String
  name: String
}

input UserUpdateOneRequiredWithoutDictionaryInput {
  create: UserCreateWithoutDictionaryInput
  update: UserUpdateWithoutDictionaryDataInput
  upsert: UserUpsertWithoutDictionaryInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutMySentencesInput {
  create: UserCreateWithoutMySentencesInput
  update: UserUpdateWithoutMySentencesDataInput
  upsert: UserUpsertWithoutMySentencesInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutDictionaryDataInput {
  email: String
  username: String
  avatar: String
  password: String
  name: String
  mySentences: SentenceUpdateManyWithoutAuthorInput
}

input UserUpdateWithoutMySentencesDataInput {
  email: String
  username: String
  avatar: String
  password: String
  name: String
  dictionary: DictionaryUpdateOneRequiredWithoutUserInput
}

input UserUpsertWithoutDictionaryInput {
  update: UserUpdateWithoutDictionaryDataInput!
  create: UserCreateWithoutDictionaryInput!
}

input UserUpsertWithoutMySentencesInput {
  update: UserUpdateWithoutMySentencesDataInput!
  create: UserCreateWithoutMySentencesInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  username: String
  username_not: String
  username_in: [String!]
  username_not_in: [String!]
  username_lt: String
  username_lte: String
  username_gt: String
  username_gte: String
  username_contains: String
  username_not_contains: String
  username_starts_with: String
  username_not_starts_with: String
  username_ends_with: String
  username_not_ends_with: String
  avatar: String
  avatar_not: String
  avatar_in: [String!]
  avatar_not_in: [String!]
  avatar_lt: String
  avatar_lte: String
  avatar_gt: String
  avatar_gte: String
  avatar_contains: String
  avatar_not_contains: String
  avatar_starts_with: String
  avatar_not_starts_with: String
  avatar_ends_with: String
  avatar_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  mySentences_every: SentenceWhereInput
  mySentences_some: SentenceWhereInput
  mySentences_none: SentenceWhereInput
  dictionary: DictionaryWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
  username: String
}
`
      }
    